# WebAssembly for a-Shell

{% hint style="warning" %}
This article is unstable.
{% endhint %}

### What is WebAssembly and how it works with a-Shell?

Due to Apple's safety policy, external binary codes outside of the app itself are forbidden to run. Thus theoretically there won't be a compiler for iOS/iPadOS that we can run and test the codes generated by it conveniently. What C/C++ compiler inside both a-Shell and Code App generates are not iOS/iPadOS native binary files but WebAssembly object codes. With the WebAssembly runtime environment, we can test the codes we write. But what is WebAssembly and why it's chosen to work with the C/C++ compiler?

As the speed of JavaScript is slow, some people hope there can be a technology that can introduce low-level program languages to the web browser, thus WebAssembly is born. It seems to be a kind of new "programming language" but actually it's a kind of object code that can be executed on different architectures and systems, and it's well-known for its safety and efficiency.

As some people have noticed WebAssembly's features, they guess it can be used to write cross-platform projects. Thus, there should be a runtime like Java to provide a way to run WebAssembly codes outside of the browser, which is called `wasi` later. WASI itself can be ported to any platforms and it provides a set of APIs for wasm programs. In a word, when a program claims it supports WebAssembly, it may be designed for two cases: either browser environments, or a kind of cross-platform runtime called `wasi`. When a program works with `wasi`, it can certainly be ported to a-Shell.

WASI built-in with a-Shell is specialized. standard `wasi-libc` only allows WebAssembly programs to read from the standard input and write to the standard output. More system calls like reading and writing files and getting directory contents have been added to a-Shell's WASI, but it still has many limits:

* No process-associated clocks. If you try to compile a program that uses `getrusage()`, there will be an explicit warning telling you to use `-D_WASI_EMULATED_PROCESS_CLOCKS` and `-lwasi-emulated-process-clocks`.
* No signal functions. Again, there will be a warning telling you to use: `-D_WASI_EMULATED_SIGNAL` and link with `-lwasi-emulated-signal`.
* No mmap function. There will be a warning telling you to use: `-D_WASI_EMULATED_MMAN` and link with `-lwasi-emulated-mman`.

There is also no `setjmp()/longjmp()`, no `fork()`, and no threads (and no ways to emulated them. There are threads in some versions of webAssembly, but they require a server, not something running locally).

WASI supports threads experimentally via web workers. For web-based projects, web workers are enabled only when the server has set certain flags. For local side, we don't know how to enable it. Apple has disabled it for security reasons.

The ecosystem of WebAssembly is still embarrassed. As a new-born technology, it has been developed for years but its usage outside of the web browser is still greatly limited.

### Cross compile WebAssembly projects with `wasi-sdk` on a-Shell for your computer

You can compile projects to WebAssembly not only with a-Shell's own tool chain, but also with a-Shell's specialized `wasi-sdk`: [https://github.com/holzschu/wasi-sdk](https://github.com/holzschu/wasi-sdk), where extra functions like reading or writing files are provided. What's more, normal `wasi-sdk`'s outputs also works with a-Shell theoretically. See also [https://github.com/WebAssembly/wasi-sdk](https://github.com/WebAssembly/wasi-sdk) for more technical details.&#x20;

ThÃ¨ following parts of this chapter focus on running `wasi-sdk` built-in with a-Shell _on the computer_.

#### Build Wasm SDK for computer

`wasi-sdk` for a-Shell provides native macOS binaries at [the GitHub repository](https://github.com/holzschu/wasi-sdk/releases). For other systems, you have to compile yourself. Generally, you have to prepare (according to the guide of `wasi-sdk` _upstream_):

+ `cmake`
+ `ninja`
+ `clang`
+ `python3`

For Windows, you may want to get the dependencies via the MinGW repository (without Cygwin or MSYS2 may work but I've never tried). Clone the repository **with submodules** on anywhere you want:

```plain
git clone --recurse-submodules https://github.com/holzschu/wasi-sdk.git
```

### Cross compile WebAssembly projects with common LLVM+Clang on your computer

Even though you don't have a specified `wasi-sdk` on the computer, it's possible to generate WASI binary files with a common LLVM+Clang toolchain (or any other available compilers). Refer to the guide of `wasi-sdk` upstream:

> One could also use a standard Clang installation, build a sysroot from the sources mentioned above, and compile with `--target=wasm32-wasi --sysroot=/path/to/sysroot`. In this scenario, one would also need the `libclang_rt.builtins-wasm32.a` objects available separately in the [release](https://github.com/WebAssembly/wasi-sdk/releases) downloads which must be extracted into `$CLANG_INSTALL_DIR/$CLANG_VERSION/lib/wasi/`.